#!/usr/bin/env python

import os, sys, getopt, re 
import datetime
import urllib
STARTUP_DIR=sys.path[0]
sys.path.append(os.path.join(STARTUP_DIR,"../../lib"))

import xmlParse

# Convert particularly large numbers 
#    into kilo/megaseconds
def km(z):
    x = int(z)
    w = z*1.0e-3
    v = z*1.0e-6
    t = z*1.0e-9
    if x>=1000:
        if x>=1000 and x<1000000:
            return "%.1fK" % w
        if x>=1000000 and x<1000000000:
            return "%.1fM" % v
        if x>=1000000000:
            return "%.1fG" % t
    if x<100:
        return "%.2f" %z
    else: return "%.1f" % z

def frontend_print(frontend, fe_mode, d, div, to_be_printed):
  
    to_be_printed.append((int(d['waste']), 
      "%-25s %6s|%6s %3d%%|%6s %3d%%|%6s %3d%%|%6s %3d%%|%9.2f %7.2f" % 
      (frontend.lstrip("frontend_"), 
      km(float(d['total_time'])/float(div)), 
      km(float(d['used'])/float(div)), 
      (float(d['used'])/float(div))/(float(d['total_time'])/float(div))*100.0, 
      km(float(d['validation'])/float(div)), 
      (float(d['validation'])/float(div))/(float(d['total_time'])/float(div))*100.0, 
      km(float(d['idle'])/float(div)), 
      (float(d['idle'])/float(div))/(float(d['total_time'])/float(div))*100.0, 
      km(float(d['waste'])/float(div)), 
      (float(d['waste'])/float(div))/(float(d['total_time'])/float(div))*100.0, 
      float(d['used'])/float(d['waste']), 
      float(d['used'])/float(d['used']+d['waste'])))) 
    return to_be_printed

def main():

    usage="""
USAGE: 
    -x [#] : interval to do verbose stats (default 24)
    --source [ABSPATH or http addr] : factory base (default current directory)
    -w : sort by wasted time
    -f [frontend] : filter by a single frontend
         (can omit "frontend_" before name)
    -p : show all periods (default off - only show 24 hours)
    -m : frontend mode - emphasize frontend data, no entries shown.
               (default data - slots).
    --ms : frontend mode, showing seconds instead of slots.
    --mh : frontend mode, showing hours instead of slots.
    -h : this usage message
"""
    x = 24
    dir = os.getcwd()

    # flags
    sort_waste = 0
    filter_frontend = 0
    show_all_periods = 0 
    frontend_mode = 0
 
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'x:hwf:pm', ['source=','ms','mh'])
    except getopt.GetoptError:
        print("\n Option not recognized or missing parameters.")
        print(" Use -h for usage.\n")
        sys.exit(0)
    for o, a in opts:
        if o == "-x":
            x = a
        elif o == "--source":
            dir = a
        elif o in ("-h", "-help"):
            print usage
            return
        elif o == "-w":
            sort_waste = 1
        elif o == "-p":
            show_all_periods = 1
        elif o == "-m":
            frontend_mode = 1
        elif o == "--ms":
            frontend_mode = 2
        elif o == "--mh":
            frontend_mode = 3
        elif o == "-f":
            filter_frontend = a
            if 'frontend_' not in filter_frontend:
                filter_frontend = 'frontend_' + filter_frontend

    data = {}
    rrd_list = {"completed_data": "rrd_Log_Completed.xml", 
                "job_dur_data": "rrd_Log_Completed_Stats.xml", 
                "wastemill_data": "rrd_Log_Completed_WasteTime.xml"}

    for name, xml in rrd_list.iteritems():

        if "http" in dir:
            file_dir = os.path.join(dir, xml)
        else: 
            file_dir = os.path.join(dir, "monitor", xml)
        try:  
            u = urllib.urlopen(file_dir)        
            data[name] = xmlParse.xmlfile2dict(u)
        except:
            print "\nCannot open", file_dir,"\n\tor",xml,"was not found there.\n"
            raise
        u.close()


    c_data = data["completed_data"]
    j_data = data["job_dur_data"]
    w_data = data["wastemill_data"]


###############################################################################
#   Rearranges rrd_data into data = [periods][frontends][entries][elements]
#      (periods are integers and in seconds)
###############################################################################

    data = {}
    frontend_list = []

    for entry in c_data['entries']:
        for frontend in c_data['entries'][entry]['frontends']:
            if frontend not in frontend_list:
                frontend_list.append(frontend)

    if filter_frontend != 0:
        if filter_frontend not in frontend_list:
            print "\nFrontend", filter_frontend, "not found at source.\n"
            print "Choices are:\n "
            for frontend in frontend_list:
                print frontend
            print
            sys.exit(1)
      
    for entry in c_data['entries']:

        for frontend in c_data['entries'][entry]['frontends']:

            if filter_frontend != 0:
                if frontend != filter_frontend:
                    continue
            
            for period in c_data['entries'][entry]['frontends'][frontend]['periods']:

                if int(period) not in data:
                    data[int(period)] = {}
                if frontend not in data[int(period)]:
                    data[int(period)][frontend] = {}
                if entry not in data[int(period)][frontend]:
                    data[int(period)][frontend][entry] = {}

                for x_data in [c_data, j_data, w_data]:
                    try:
                       for a, b in x_data['entries'][entry]['frontends'][frontend]['periods'][period].iteritems():
                            data[int(period)][frontend][entry][a] = int(float(b)*int(period))   
                    except:
                        print "\nEntry %s in one of the RRDs is missing %s; continuing\n" % (entry, frontend)
    

######################################################################
# Organize totals/stats for each period, frontend, and entry independantly
######################################################################

    if filter_frontend == 0:
        print("""
Glidein log analysis for All Entries - %s
""" % datetime.datetime.now().strftime("%d-%m-%Y_%H:%M:%S"))
    else: print("""
Glidein log analysis for frontend %s - %s
""" % (filter_frontend, datetime.datetime.now().strftime("%d-%m-%Y_%H:%M:%S")))

    attributes = {'glideins':0,'jobs':0,'used':0,'waste':0,
                  'validation':0,'idle':0,'badput':0,'total_time':0} 

    period_data = {}
    frontend_data = {}
    entry_data = {}
    entry_data_all_frontends = {}
    
    for period, frontends in data.iteritems():
        period = int(period)
        period_data[period] = {}
        frontend_data[period] = {}
        entry_data[period] = {}
        entry_data_all_frontends[period] = {}
        for a in attributes.keys(): period_data[period][a]=0

        for frontend, entries in frontends.iteritems(): 
            frontend_data[period][frontend] = {}
            entry_data[period][frontend] = {}
            for a in attributes.keys(): frontend_data[period][frontend][a]=0

            for entry, elements in entries.iteritems():
                entry_data[period][frontend][entry] = {}  
                for a in attributes.keys(): entry_data[period][frontend][entry][a]=0

                #may have gotten entry from another frontend
                if entry not in entry_data_all_frontends[period]:
                    entry_data_all_frontends[period][entry] = {}
                    for a in attributes.keys(): entry_data_all_frontends[period][entry][a]=0

                attributes['glideins'] = elements["Glideins"]
                attributes['jobs'] = elements["JobsNr"]
                attributes['used'] = elements["JobsLasted"]
                attributes['total_time'] = elements["Lasted"]
                attributes['waste'] = elements["Lasted"] - elements["JobsLasted"]
                attributes['badput'] = elements["Lasted"] - elements["JobsGoodput"]
                attributes['validation'] = 0
                attributes['idle'] = 0 

                for name, value in elements.iteritems():
                    if 'validation' in name:
                        multiplier = re.findall('validation_(.*)', name)[0].rstrip('m')
                        if multiplier == "All": multiplier = 1000
                        if multiplier == "Most": multiplier = 750 # approximation
                        if multiplier == "None": multiplier = 0
                        attributes['validation'] += value*(int(multiplier)*1.0e-3)
                    if 'idle' in name:
                        multiplier = re.findall('idle_(.*)', name)[0].rstrip('m')
                        if multiplier == "All": multiplier = 1000
                        if multiplier == "Most": multiplier = 750 # approximation
                        if multiplier == "None": multiplier = 0
                        attributes['idle'] += value*(int(multiplier)*1.0e-3)

                for a in attributes.keys():
                    entry_data[period][frontend][entry][a] += attributes[a]
                    frontend_data[period][frontend][a] += attributes[a] 
                    period_data[period][a] += attributes[a] 
                    entry_data_all_frontends[period][entry][a] += attributes[a]

                for a in ['FailedNr','validation_All','JobsNr_None','badput_All','Lasted']:
                    if a not in entry_data_all_frontends[period][entry]:
                        entry_data_all_frontends[period][entry][a] = data[period][frontend][entry][a]
                    else: entry_data_all_frontends[period][entry][a] += data[period][frontend][entry][a]

                

######################################################################
#   Print
######################################################################

    # sort periods from least to greatest, with 24 hours at the top 
    period_list = period_data.keys()
    period_list.sort()
    period_list.remove(86400)
    period_list.insert(0,86400) 

    period = int(x)*3600

    # if filtering by period, make sure it's in the data
    if period not in period_list:
        print "Interval",x,"does not exist in data.\n Choices are:"
        for a in period_list:
           print a/3600
        print
        return

    # default - show only one period, either user-chosen or default(24)
    if show_all_periods==0:
        period_list = [period] 

    for p in period_list:
        title = ("Past %.1f hours" % (float(p)/3600))
       
        # if no glideins, omit this entry
        if period_data[p]['glideins'] == 0:
            continue        
        # to avoid division by zero
        if period_data[p]['waste'] == 0:
            period_data[p]['waste'] = 1

        d = period_data[p]
        print(
"""----------------------------------------
%s:

Total Glideins: %s
Total Jobs: %d (Average jobs/glidein: %.2f) 

Total time:            %8ss (%6s hours - %6.1f slots)
Total time used:       %8ss (%6s hours - %6.1f slots - %2d%%)
Total time validating: %8ss (%6s hours - %6.1f slots - %2d%%)
Total time idle:       %8ss (%6s hours - %6.1f slots - %2d%%)
Total time wasted:     %8ss (%6s hours - %6.1f slots - %2d%%)
Time used/time wasted: %.1f
Time efficiency: %.2f
"""
      % (title, 
        d['glideins'], 
        d['jobs'], 
        float(d['jobs'])/float(d['glideins']),

        km(d['total_time']),
        km(d['total_time']/3600),
        float(d['total_time'])/float(p),

        km(d['used']),
        km(d['used']/3600), 
        float(d['used'])/float(p),
        float(d['used'])/float(d['total_time'])*100.0,

        km(d['validation']),
        km(d['validation']/3600), 
        float(d['validation'])/float(p),
        float(d['validation'])/float(d['total_time'])*100.0,

        km(d['idle']),
        km(d['idle']/3600), 
        float(d['idle'])/float(p),
        float(d['idle'])/float(d['total_time'])*100.0,

        km(d['waste']),
        km(d['waste']/3600), 
        float(d['waste'])/float(p),
        float(d['waste'])/float(d['total_time'])*100.0,

        float(d['used'])/float(d['waste']),
        float(d['used'])/float(d['waste']+d['used'])))


################################################################################
#    Print per entry stats (all frontends)
################################################################################


    if filter_frontend==0 and frontend_mode==0:

        print """
---------------------------------------
---------------------------------------
Per Entry (all frontends) stats for the past %s hours.\n""" % x

        print("%-40s%5s %3s %4s | %4s %4s %4s %4s | %6s %7s %7s" % ( 
                  "", "strt","fval","0job","val","idle","wst","badp","waste","time","total"))

        to_be_printed = []  # dict of paired entry data with wastetime for sorting

        for entry_name, entry in entry_data_all_frontends[period].iteritems():
 
            if entry['glideins'] == 0 or entry['total_time'] == 0:
                continue
            if entry['validation'] == 0:
                entry['validation'] = 1
            
            to_be_printed.append((int(entry['waste']), "%-40s %3d%% %3d%% %3d%% | %3d%% %3d%% %3d%% %3d%% | %6d  %6d  %1s %4d" 
                 % (entry_name.lstrip("entry_"),
                    (float(entry['FailedNr'])/float(entry['glideins']))*100,
                    (float(entry['validation_All'])/float(entry['total_time']))*100,
                    (float(entry['JobsNr_None'])/float(entry['glideins']))*100,
                    #(float(entry['badput_All'])/float(entry['total_time']))*100,
                    (float(entry['validation'])/float(entry['total_time']))*100,
                    (float(entry['idle'])/float(entry['total_time']))*100,
                    (float(entry['waste'])/float(entry['total_time']))*100,
                    (float(entry['badput'])/float(entry['total_time']))*100,
                    entry['waste']/3600.0,
                    #(entry_data[period][frontend][entry]['used']+entry_data[period][frontend][entry]['waste'])/3600.0,
                    entry['Lasted']/3600.0,
                    "|",
                    entry['glideins'])))

        if sort_waste == 1:
            to_be_printed.sort()
            to_be_printed.reverse()
            for a in to_be_printed:
                print a[1] 
            print("----------------------------------")
        else: 
            for a in to_be_printed:
                print a[1] 


################################################################################
#    Print per frontend per entry stats
################################################################################



    if frontend_mode==0:
        print """
---------------------------------------
---------------------------------------
Per Entry (per frontend) stats for the past %s hours.\n""" % (x)
    else:
        units = ["Slots","Seconds","Hours"]
        print """
---------------------------------------
---------------------------------------
Frontend stats for the past %s hours.\n""" % (x)
        print("%-25s%7s %7s %3s %7s %3s %7s %3s %7s %3s %11s %4s\n" % (
              "Units: "+units[frontend_mode-1], "total","used","u%","val","v%","idle","i%","waste","w%","usd/wst","eff"))

    fe_to_be_printed = []

    for frontend, entries in data[period].iteritems():
        d = frontend_data[period][frontend]
        #print frontend, "\n"
        #print d, "\n"

        if period_data[period]['glideins'] == 0 or d['glideins'] == 0:
            continue
        # to avoid divisions by zero
        if d['waste'] == 0:
            d['waste'] = 1

        if frontend_mode == 0:
            print ("""
\n%s

Glideins: %s - %.1f%% of total
Jobs: %s (Average jobs/glidein: %.2f)

Total time:            %8ss (%6s hours - %6.1f slots)
Total time used:       %8ss (%6s hours - %6.1f slots - %2d%%)
Total time validating: %8ss (%6s hours - %6.1f slots - %2d%%)
Total time idle:       %8ss (%6s hours - %6.1f slots - %2d%%)
Total time wasted:     %8ss (%6s hours - %6.1f slots - %2d%%)
Time used/time wasted: %.1f
Time efficiency: %.2f
""" % ( frontend,
        d['glideins'], 
        float(d['glideins'])/float(period_data[period]['glideins'])*100, 
        d['jobs'], 
        float(d['jobs'])/float(d['glideins']), 

        km(d['total_time']),
        km(d['total_time']/3600),
        float(d['total_time'])/float(period), 

        km(d['used']), 
        km(d['used']/3600), 
        float(d['used'])/float(period), 
        float(d['used'])/float(d['total_time'])*100.0,	

        km(d['validation']), 
        km(d['validation']/3600), 
        float(d['validation'])/float(period),
        float(d['validation'])/float(d['total_time'])*100.0,

        km(d['idle']), 
        km(d['idle']/3600),
        float(d['idle'])/float(period), 
        float(d['idle'])/float(d['total_time'])*100.0,

        km(d['waste']), 
        km(d['waste']/3600),
        float(d['waste'])/float(period), 
        float(d['waste'])/float(d['total_time'])*100.0,

        float(d['used'])/float(d['waste']),
        float(d['used'])/(float(d['waste'])+float(d['used'])))) 
            
            print("%-40s%5s %3s %4s | %4s %4s %4s %4s | %6s %7s %7s" % (
              "", "strt","fval","0job","val","idle","wst","badp","waste","time","total"))

            to_be_printed = []  # dict of paired entry data with wastetime for sorting
            for entry, e in entries.iteritems():
                en = entry_data[period][frontend][entry] 
                if en['glideins'] == 0 or e['Lasted'] == 0:
                    continue
                if en['validation'] == 0:
                    en['validation'] = 1

                to_be_printed.append((int(entry_data[period][frontend][entry]['waste']), 
                        "%-40s %3d%% %3d%% %3d%% | %3d%% %3d%% %3d%% %3d%% | %6d  %6d  %1s %4d" 
                   % (entry.lstrip("entry_"),
                        (float(e['FailedNr'])/float(en['glideins']))*100,
                        (float(e['validation_All'])/float(e['Lasted']))*100,
                        (float(e['JobsNr_None'])/float(en['glideins']))*100,
                        (float(en['validation'])/float(e['Lasted']))*100,
                        (float(en['idle'])/float(e['Lasted']))*100,
                        (float(en['waste'])/float(e['Lasted']))*100,
                        (float(en['badput'])/float(e['Lasted']))*100,
                        en['waste']/3600.0,
                        e['Lasted']/3600.0,
                        "|",
                        entry_data[period][frontend][entry]['glideins'])))

            if sort_waste == 1:
                to_be_printed.sort()
                to_be_printed.reverse()
                for a in to_be_printed:
                    print a[1]
                print("----------------------------------")
            else: 
                for a in to_be_printed:
                    print a[1] 

         
        else: # print frontend like entries, and omit entries
            divs = [period,1.0,3600.0]
            fe_to_be_printed = frontend_print(frontend, frontend_mode,d,divs[frontend_mode-1],fe_to_be_printed)
            
    if sort_waste == 1:
        fe_to_be_printed.sort()
        fe_to_be_printed.reverse()
        for a in fe_to_be_printed:
            print a[1]
        print("----------------------------------")
    else: 
        for a in fe_to_be_printed:
            print a[1] 

################################################################################
#    Print Key
################################################################################

    if frontend_mode==0:
        print("""\n-----------------------------------
LEGEND:

K - kilseconds (*1,000 seconds)
M - megaseconds (*1,000,000 seconds)

strt - % of jobs where condor failed to start
fval - % of glideins that failed to validate (hit 1000s limit)
0job - %  0 jobs/glidein
----------
val - % of time used for validation
idle - % of time spend idle
wst - % of time wasted (Lasted - JobsLasted) 
badp - % of badput (Lasted - JobsGoodput)
----------
waste - wallclock time wasted (hours) (Lasted - JobsLasted)
time - total wallclock time (hours) (Lasted)
total - total number of glideins
-------------------------------------
        \n""")

    else: #frontend_mode legend
        print("""\n-----------------------------------
LEGEND:

K - kilseconds (*1,000 seconds)
M - megaseconds (*1,000,000 seconds)

total - total number of units (slots, seconds or hours,
        see units in upper left hand corner of frontend stats.
----------
used - time used 
val  - time spent validating
idle - time spent idle
wst  - time wasted (Lasted - JobsLasted) 

u,v,i,w% - percentage of previous corresponding attribute
           (used, val, idle, waste) over total time
----------
usd/wst - ratio of time used to time wasted
eff     - efficiency - time used over total time 
-------------------------------------
        \n""")


if __name__ == "__main__":
    main()


